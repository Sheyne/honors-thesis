\documentclass{article}
    % General document formatting
    \usepackage[margin=0.7in]{geometry}
    \usepackage[parfill]{parskip}
    \usepackage{amsopn}
    \usepackage{mathtools}
    \usepackage[utf8]{inputenc}
    \usepackage{hyperref}
    \usepackage{multicol}
    \usepackage{amsmath,amssymb,amsfonts,amsthm}

    \DeclareMathOperator{\StringT}{StringT}
    \DeclareMathOperator{\NumberT}{NumberT}
    \DeclareMathOperator{\BooleanT}{BooleanT}
    \DeclareMathOperator{\LitT}{LitT}
    \DeclareMathOperator{\JSLit}{JSLit}
    \DeclareMathOperator{\JSTypeof}{JSTypeof}
    \DeclareMathOperator{\RecT}{RecT}
    \DeclareMathOperator{\ObjT}{ObjT}
    \DeclareMathOperator{\ListT}{ListT}
    \DeclareMathOperator{\SetT}{SetT}
    \DeclareMathOperator{\MapT}{MapT}
    \DeclareMathOperator{\ObjType}{ObjType}
    \DeclareMathOperator{\UnionT}{UnionT}
    \DeclareMathOperator{\InterT}{InterT}
    \DeclareMathOperator{\LookupObjRef}{LookupObjRef}
    \DeclareMathOperator{\String}{String}
    \DeclareMathOperator{\Number}{Number}
    \DeclareMathOperator{\Boolean}{Boolean}
    \DeclareMathOperator{\type-ref}{ref}
    \DeclareMathOperator{\Type}{Type}
    \DeclareMathOperator{\NoSuper}{NoSuper}
    \DeclareMathOperator{\InterOrObj}{InterOrObj}
    \DeclareMathOperator{\ObjectSubtype}{ObjectSubtype}
    \DeclareMathOperator{\RecordSubtype}{RecordSubtype}
    \DeclareMathOperator{\Value}{Value_\Sigma}
    \DeclareMathOperator{\StringV}{StringV_\Sigma}
    \DeclareMathOperator{\NumberV}{NumberV_\Sigma}
    \DeclareMathOperator{\BooleanV}{BooleanV_\Sigma}
    \DeclareMathOperator{\RecV}{RecV_\Sigma}
    \DeclareMathOperator{\ObjV}{ObjV_\Sigma}
    \DeclareMathOperator{\ListV}{ListV_\Sigma}
    \DeclareMathOperator{\SetV}{SetV_\Sigma}
    \DeclareMathOperator{\MapV}{MapV_\Sigma}
    \DeclareMathOperator{\UnionV}{UnionV_\Sigma}
    \DeclareMathOperator{\ValueType}{ValueType_\Sigma}
    \DeclareMathOperator{\textref}{ref}
    \DeclareMathOperator{\ObjFields}{ObjFields}
    \DeclareMathOperator{\ObjPairsMatch}{ObjPairsMatch}
    \DeclareMathOperator{\where}{ where }
    \DeclareMathOperator{\textif}{ if }
    \DeclareMathOperator{\suchthat}{s.t.}
    \newcommand{\ValueRef}{\textref}
    \newcommand{\ValueDeref}[1]{\Sigma(#1)}
\begin{document}
\begin{multicols}{2}
\section{Intro}

Sinap IDE is a program to allow editing of graph
programs in various graph programming langauages. 
Because it wants to be an editor for many different
graph-languages, a pluggable architecture was designed
so that Sinap could change its user interface (UI)
to best support each language. 

The idea is that while editing a graph, components of the
graph will have different attributes associated with them 
that the editor should present contextually. For example, in
a graph-language describing deterministic finite-state 
automata (DFAs) edges should have a ``symbol" attribute of 
type character corresponding to the input by which this 
edge should be followed. 

As you can see in Figure \ref{sinap-screenshot}, Sinap's UI
presents the user with nodes and edges which can be selected 
and edited in the sidebar. Allowing the sidebar to change based
on what interpreter is what the type-system facilitates. 

\begin{figure} 
    \label{sinap-screenshot}  
    \includegraphics[width=\textwidth]{sinap-screenshot}
    \caption{Sinap IDE editing a graph}
\end{figure}
    
Sinap's typeâ€“system consists of two parts:

\begin{enumerate}
    \item A data-language to describe graph components 
    (implemented in values.ts)
    \item A data-description language to define valid schema 
    (implemented in types.ts)
    for the data language
\end{enumerate}

The code for both can be found at 

\href{https://github.com/2graphic/sinap-types}
{https://github.com/2graphic/sinap-types}.

The data that are allowable in the sidebar can be more complicated than
simple strings and numbers. In the example above the ``Position" attribute
of the node has a structure that similar to the following TypeScript code:

\begin{samepage}
\begin{verbatim}
type Point = {
    x: number;
    y: number;
}
\end{verbatim}
\end{samepage}

Although there fields aren't limited to simple types and the 
whole structure can nest. \textbf{TODO: awkward phrasing, reword}. 

\subsection{Notation}
The symbol \((\operatorname{Kind}_1, ...)\) is equivalent to 
\((\operatorname{Kind}_i)\). They are also equivalent to 
\((\operatorname{Kind}_1, ..., \operatorname{Kind}_n)\)
where \(n\) is unspecified and represent an ordered list 
of \(n\) elements. \(\{\operatorname{Kind}_i\}\) represents 
the set of the elements of the list. 

``\(\_\)'' represents a symbol that has been omitted for brevity.
\end{multicols}

\section{The Type System}

\textbf{TODO: edit this next paragraph}
The goal of creating the above language (referred to as Sinap's 
Type System) is to allow interpreter implementers to specify what 
kinds of graphs are valid for their interpreter. This means that 
graphs can allow various fields on nodes and edges and the interpreter
can guarantee that the fields are present on all of the nodes that it
is passed. It also allows different kinds of nodes and edges to be 
specified and for rules to exists defining what kinds of nodes can 
via which edges. 


The data-description language is called the type system and has 
the following structure:

\textbf{TODO: motivate \(\LitT\)}

\begin{align*}
\begin{aligned}
\Type = &\LitT(\JSLit) \\
&|\StringT \\
&|\NumberT \\
&|\BooleanT \\
&|\RecT((\String, \Type), ...) \\
&|\ListT(\Type) \\
&|\SetT(\Type) \\
&|\MapT(\Type, \Type) \\
&|\ObjT\left(\begin{aligned}
    &\String, \String | \NoSuper, \\
&((\String, \Type), ...)
\end{aligned}\right) \\
&|\InterT(\ObjT, ...) \\
&|\UnionT(\Type, ...)\\
\end{aligned}
\quad\quad\quad\begin{aligned}        
\begin{aligned}
\JSLit = &\operatorname{JSString} \\
&| \operatorname{JSNumber} \\
&| \operatorname{true} \\
&| \operatorname{false} \\
\end{aligned}\\\\
\begin{aligned}
\JSTypeof(\operatorname{JSString}) &= \StringT \\
\JSTypeof(\operatorname{JSNumber}) &= \NumberT \\
\JSTypeof(\operatorname{true}) &= \BooleanT \\
\JSTypeof(\operatorname{false}) &= \BooleanT \\
\end{aligned}  
\end{aligned}  
\end{align*}

\subsection{Subtype Relations}

Define \(\bullet<:\bullet\)

\begin{align*}
    \Type_1&<:\Type_1 \\
    \LitT(\JSLit_1)&<:\Type_1 &&\textif \JSTypeof(\JSLit_1) = \Type_1 \\
    \InterT(\Type_{1,1}, ..., \Type_{1,n})&<:\InterT(\Type_{2,1}, ..., Type_{2,m}) 
    &&\textif \forall T\in \{\Type_{2,i}\} \exists T' \in \{\Type_{1,i}\} \suchthat T'<:T \\
    \InterT(..., \Type_i, ...)&<:\ObjT_1 &&\textif \ObjT_1 = \Type_i  \\
    \ObjT_1 &<: \ObjT(\String_1, \_, \_) &&\textif \ObjectSubtype(\String_1, \ObjT_1)\\
    \RecT_1&<:\RecT_2 &&\textif \RecordSubtype(\RecT_1, \RecT_2) \\
    \ListT(\Type_1)&<:\ListT(\Type_2) &&\textif \Type_1<:\Type_2 \\
    \SetT(\Type_1)&<:\SetT(\Type_2) &&\textif \Type_1<:\Type_2 \\
    \MapT(\Type_{11}, \Type_{12})&<:\MapT(\Type_{21}, \Type_{22}) &&\textif \Type_{11}<:\Type_{21} \text{ and } \Type_{12}<:\Type_{22} \\
\end{align*}
\begin{align*}
    \ObjectSubtype(\String_1, \ObjT(\String_2,\_, \_)) \quad &\textif 
    \quad (\String_1 = \String_2)\\
    \ObjectSubtype(\String_1, \ObjT(\_,\String_2, \_)) \quad &\textif 
    \quad \ObjectSubtype(\String_1, \LookupObjRef(\String_2)))
\end{align*}
\begin{align*}
    \RecordSubtype(\RecT((\String_{1,1}, \Type_{1, 1}), ..., (\String_{1,n}, \Type_{1, n})), \RecT((\String_{2,1}, \Type_{2, 1}), ..., (\String_{2,m}, \Type_{2, m}))) \\
    \textif \{\String_{2,i}\} \subset \{\String_{1,i}\} \text{ and } \String_{1, i} = \String_{2, j} \implies \Type_{1, i} <: \Type_{2, j}
\end{align*}
    
Note that this actually allows for some weirdness, because 
we lose some of the restrictions of the subtype Map when using
it as the supertype. This is incredibly unlikely in the use case 
of Sinap because data aren't reused between different nodes and
edges. 

Records are structurally typed, two records with the same structure have
the same type. Objects are nominally typed, so the type system needs some
notion of references to support them. 

While Sinap's Type System is implemented as a library and can have 
concrete syntaxes in several languages, our most mature implementation 
is in TypeScript. 

An example of how this translation is applied is given below.

\begin{align*}
    \text{Nodes} = &\UnionT\left(
        \begin{aligned}
        &\ObjT\left(
            \begin{aligned}    
                \text{``Node1"}, \NoSuper, \left(
                    \begin{aligned}
                        &(\text{``label"}, \StringT),  \\
                        &(\text{``customAttribute"}, \NumberT)
                    \end{aligned}\right)
            \end{aligned}\right),  \\
        &\ObjT\left(\text{``Node2"}, \NoSuper, \left(\begin{aligned}
            (&\text{``label"}, \StringT),  \\
            (&\text{``otherAttribute"}, \RecT\left(
                \begin{aligned}
                    (&\text{``f1"}, \BooleanT),  \\
                    (&\text{``f2"}, \NumberT)
                \end{aligned}\right)
        \end{aligned}\right)\right)
        \end{aligned}\right)  \\
    \text{Edges} = &\UnionT\left(\ObjT\left(
        \text{``Edge"}, \NoSuper,  
        \left(\begin{aligned}
            (&\text{``label"}, \StringT), \\
            (&\text{``source"}, \ObjT(\text{``Node1"}, \_, \_)), \\
            (&\text{``destination"}, \ObjT(\text{``Node2"}, \_, \_)) \\             
        \end{aligned}\right)\right)\right)
\end{align*}
The above is equivalent to the following TypeScript:

\begin{verbatim}
class Node1 {
    label: string;
    customAttribute: number;
}

class Node2 {
    label: string;
    otherAttribute: {
        f1: boolean,
        f2: number
    };
}

class Edge {
    label: string
    source: Node1;
    destination: Node2;
}

type Nodes = Node1 | Node2;
type Edges = Edge;
\end{verbatim}

\section{Values}

Now that we have a description of valid graph structures for some
interpreter, we need to define a language for describing specific 
graphs. 

\textbf{TODO: explain \(\Sigma\). Per Matt: ``An arguments that threads through the 
object graph."}

\begin{align*}
    \Value =& \StringV(\Type_1, \String_1) \quad\where \Type_1 <: \StringT \\
    &| \NumberV(\Type_1, \Number_1) \quad\where \Type_1 <: \NumberT \\
    &| \BooleanV(\Type_1, \Boolean_1) \quad\where \Type_1 <: \BooleanT \\
    &| \ObjV(\Type_1, V=((\String_1, \ValueRef_1), ...)) \quad\where 
    \ObjPairsMatch(\ObjFields(\Type_1), V) \\
    &| \UnionV(\UnionT(..., \Type_i, ...), \ValueRef_1) \where
    \ValueType(\ValueRef_1) <: \Type_i\\
    &| \ListV(\ListT(\Type_1), (\ValueRef_1, ...)) \where \ValueType(\ValueRef_i) <: \Type_1 \\
    &| \SetV(\SetT(\Type_1), \{\ValueRef_1, ...\}) \where \ValueType(\ValueRef_i) <: \Type_1 \\
    &| \MapV(\MapT(\Type_1, \Type_2), ((\ValueRef_{1,1}, \ValueRef_{2,1}), ...)) \where \bigwedge
    \begin{aligned}
        \ValueType(\ValueRef_{1, i}) <: \Type_1 \\
        \ValueType(\ValueRef_{2, i}) <: \Type_2 
    \end{aligned}\\
\end{align*}

\begin{align*}
    \ObjFields(\ObjT(\_, \String_S, (P_1 = (\String_1, \Type_1), ...))) &= \operatorname{concat}(\ObjFields(\LookupObjRef(\String_S), (P_n))) \\
    \ObjFields(\InterT(ObjT_1, ...)) &= \operatorname{concat}(\ObjFields(\ObjT_1), ...)
\end{align*}

\begin{align*}
    \ValueType(\ValueRef_1) &= \ValueType(\ValueDeref{\ValueRef_1}) \\
    \ValueType(\StringV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\NumberV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\BooleanV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\ObjV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\UnionV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\ListV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\SetV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\MapV(\Type_1, \_)) &= \Type_1 \\
\end{align*}
\begin{align*}
    \ObjPairsMatch(((\String_1, \Type_1),...), ((\String_1, \ValueRef_1), ...)) 
    \textif \forall i, \ValueType(\Value_i) <: \Type_i
\end{align*}

A valid graph then matches 
\[(\ListV(\ListT(\operatorname{Nodes}), \_), \ListV(\ListT(\operatorname{Edges}), \_))\]
for some appropriate definition of Nodes and Edges.

\end{document}

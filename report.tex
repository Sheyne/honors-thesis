\documentclass{article}
    % General document formatting
    \usepackage[margin=0.7in]{geometry}
    \usepackage[parfill]{parskip}
    \usepackage{amsopn}
    \usepackage{mathtools}
    \usepackage[utf8]{inputenc}
    \usepackage{hyperref}
    
    % Related to math
    \usepackage{amsmath,amssymb,amsfonts,amsthm}

    \DeclareMathOperator{\StringT}{StringT}
    \DeclareMathOperator{\NumberT}{NumberT}
    \DeclareMathOperator{\BooleanT}{BooleanT}
    \DeclareMathOperator{\LitT}{LitT}
    \DeclareMathOperator{\JSLit}{JSLit}
    \DeclareMathOperator{\JSTypeof}{JSTypeof}
    \DeclareMathOperator{\RecT}{RecT}
    \DeclareMathOperator{\ObjT}{ObjT}
    \DeclareMathOperator{\ListT}{ListT}
    \DeclareMathOperator{\SetT}{SetT}
    \DeclareMathOperator{\MapT}{MapT}
    \DeclareMathOperator{\ObjType}{ObjType}
    \DeclareMathOperator{\UnionT}{UnionT}
    \DeclareMathOperator{\InterT}{InterT}
    \DeclareMathOperator{\LookupObjRef}{LookupObjRef}
    \DeclareMathOperator{\String}{String}
    \DeclareMathOperator{\Number}{Number}
    \DeclareMathOperator{\Boolean}{Boolean}
    \DeclareMathOperator{\type-ref}{ref}
    \DeclareMathOperator{\Type}{Type}
    \DeclareMathOperator{\NoSuper}{NoSuper}
    \DeclareMathOperator{\InterOrObj}{InterOrObj}
    \DeclareMathOperator{\ObjectSubtype}{ObjectSubtype}
    \DeclareMathOperator{\RecordSubtype}{RecordSubtype}
    \DeclareMathOperator{\Value}{Value}
    \DeclareMathOperator{\StringV}{StringV}
    \DeclareMathOperator{\NumberV}{NumberV}
    \DeclareMathOperator{\BooleanV}{BooleanV}
    \DeclareMathOperator{\RecV}{RecV}
    \DeclareMathOperator{\ObjV}{ObjV}
    \DeclareMathOperator{\ListV}{ListV}
    \DeclareMathOperator{\SetV}{SetV}
    \DeclareMathOperator{\MapV}{MapV}
    \DeclareMathOperator{\UnionV}{UnionV}
    \DeclareMathOperator{\ValueType}{ValueType}
    \DeclareMathOperator{\textref}{ref}
    \DeclareMathOperator{\ObjFields}{ObjFields}
    \DeclareMathOperator{\ObjPairsMatch}{ObjPairsMatch}
    \DeclareMathOperator{\where}{ where }
    \DeclareMathOperator{\textif}{ if }
    \DeclareMathOperator{\suchthat}{s.t.}
    \newcommand{\ValueRef}{(\textref_{\Value})}    
\begin{document}


\section{Intro}

Sinap IDE is a program to allow editing of arbitrary graph
programming languages. Because it wants to be an editor for 
many different languages, a pluggable architecture was 
designed so that Sinap could change its user interface (UI)
to best support each language. 

This interface consisted of two parts:

\begin{enumerate}
    \item A data-language to describe graph components
    \item A data-description language to define valid schema
    for the data language
\end{enumerate}

The idea is that while editing a graph, components of the
graph will have different attributes associated with them 
that the editor should present contextually. For example, in
a graph-language describing deterministic finite-state 
automata (DFAs) edges should have a ``symbol" attribute of 
type character corresponding to the input by which this 
edge should be followed. 

More complex data-types should also be allowed, such that
nodes could have, for example, a ``dog" attribute which, 
to use TypeScript syntax, the following structure:

\begin{verbatim}
class Dog {
    name: string;
    age: number;
    weight: number;
}
\end{verbatim}

With the ability for each of the fields themselves to have the 
same kind of rich types. 

\subsection{Notation}
The symbol \((\operatorname{Kind}_1, ...)\) is equivalent to 
\((\operatorname{Kind}_i)\). They are also equivalent to 
\((\operatorname{Kind}_1, ..., \operatorname{Kind}_n)\)
where \(n\) is unspecified and represent an ordered list 
of \(n\) elements. \(\{\operatorname{Kind}_i\}\) represents 
the set of the elements of the list. 

\section{The Type System}

The data-description language is called the type system and has 
the following structure:

\begin{align*}
\Type = &\LitT(\JSLit) \\
&|\StringT \\
&|\NumberT \\
&|\BooleanT \\
&|\RecT((\String, \Type), ...) \\
&|\ListT(\Type) \\
&|\SetT(\Type) \\
&|\MapT(\Type, \Type) \\
&|\ObjT(\String, \String | \NoSuper, ((\String, \Type), ...)) \\
&|\InterT(\ObjT, ...) \\
&|\UnionT(\Type, ...)\\
\end{align*}

Use the definitions of ``string" and ``number" from
\href{https://www.json.org/}{https://www.json.org/}, 
and call them \(\operatorname{JSString}\) and 
\(\operatorname{JSNumber}\) respectively.

\begin{align*}
    \JSLit = &\operatorname{JSString} \\
    &| \operatorname{JSNumber} \\
    &| \operatorname{true} \\
    &| \operatorname{false} \\
\end{align*}

\begin{align*}
    \JSTypeof(\operatorname{JSString}) &= \StringT \\
    \JSTypeof(\operatorname{JSNumber}) &= \NumberT \\
    \JSTypeof(\operatorname{true}) &= \BooleanT \\
    \JSTypeof(\operatorname{false}) &= \BooleanT \\
\end{align*}

\subsection{Subtype Relations}

Define \(\bullet<:\bullet\)

\begin{align*}
    \Type_1&<:\Type_1 \\
    \LitT(\JSLit_1)&<:\Type_1 \quad \textif \JSTypeof(\JSLit_1) = \Type_1 \\
    \InterT(\Type_{1,1}, ..., \Type_{1,n})&<:\InterT(\Type_{2,1}, ..., Type_{2,m}) 
    \quad \textif \forall T\in \{\Type_{2,i}\} \exists T' \in \{\Type_{1,i}\} \suchthat T'<:T \\
    \InterT(..., \Type_i, ...)&<:\ObjT_1 \quad \textif \ObjT_1 = \Type_i  \\
    \ObjT_1 &<: \ObjT(\String_1, \_, \_) \quad \textif \ObjectSubtype(\String_1, \ObjT_1)\\
    \RecT_1&<:\RecT_2 \quad \textif \RecordSubtype(\RecT_1, \RecT_2) \\
    \ListT(\Type_1)&<:\ListT(\Type_2) \quad \textif \Type_1<:\Type_2 \\
    \SetT(\Type_1)&<:\SetT(\Type_2) \quad \textif \Type_1<:\Type_2 \\
    \MapT(\Type_{11}, \Type_{12})&<:\MapT(\Type_{21}, \Type_{22}) \quad \textif \Type_{11}<:\Type_{21} \text{ and } \Type_{12}<:\Type_{22} \\
\end{align*}
\begin{align*}
    \ObjectSubtype(\String_1, \ObjT(\String_2,\_, \_)) \quad &\textif 
    \quad (\String_1 = \String_2)\\
    \ObjectSubtype(\String_1, \ObjT(\_,\String_2, \_)) \quad &\textif 
    \quad \ObjectSubtype(\String_1, \LookupObjRef(\String_2)))
\end{align*}
\begin{align*}
    \RecordSubtype(\RecT((\String_{1,1}, \Type_{1, 1}), ..., (\String_{1,n}, \Type_{1, n})), \RecT((\String_{2,1}, \Type_{2, 1}), ..., (\String_{2,m}, \Type_{2, m}))) \\
    \textif \{\String_{2,i}\} \subset \{\String_{1,i}\} \text{ and } \String_{1, i} = \String_{2, j} \implies \Type_{1, i} <: \Type_{2, j}
\end{align*}

Note that this actually allows for some weirdness, because 
we lose some of the restrictions of the subtype Map when using
it as the supertype. This is incredibly unlikely in the use case 
of Sinap because data aren't reused between different nodes and
edges. 

Records are structurally typed, two records with the same structure have
the same type. Objects are nominally typed, so the type system needs some
notion of references to support them. 

The goal of creating the above language (referred to as Sinap's 
Type System) is to allow interpreter implementers to specify what 
kinds of graphs are valid for their interpreter. This means that 
graphs can allow various fields on nodes and edges and the interpreter
can guarantee that the fields are present on all of the nodes that it
is passed. It also allows different kinds of nodes and edges to be 
specified and for rules to exists defining what kinds of nodes can 
via which edges. 

While Sinap's Type System is implemented as a library and can have 
concrete syntaxes in several languages, our most mature implementation 
is in typescript. 

An example of how this translation is applied is given below.

\begin{verbatim}
class Node1 {
    label: string;
    customAttribute: number;
}

class Node2 {
    label: string;
    otherAttribute: {
        f1: boolean,
        f2: number
    };
}

class Edge {
    label: string
    source: Node1;
    destination: Node2;
}

type Nodes = Node1 | Node2;
type Edges = Edge;
\end{verbatim}

The above TypeScript gets converted to the following representation:
\begin{align*}
    \text{Nodes} = &\UnionT\left(
        \begin{aligned}
        &\ObjT\left(
            \begin{aligned}    
                \text{``Node1"}, \NoSuper, \left(
                    \begin{aligned}
                        &(\text{``label"}, \StringT),  \\
                        &(\text{``customAttribute"}, \NumberT)
                    \end{aligned}\right)
            \end{aligned}\right),  \\
        &\ObjT\left(\text{``Node2"}, \NoSuper, \left(\begin{aligned}
            (&\text{``label"}, \StringT),  \\
            (&\text{``otherAttribute"}, \RecT\left(
                \begin{aligned}
                    (&\text{``f1"}, \BooleanT),  \\
                    (&\text{``f2"}, \NumberT)
                \end{aligned}\right)
        \end{aligned}\right)\right)
        \end{aligned}\right)  \\
    \text{Edges} = &\UnionT\left(\ObjT\left(
        \text{``Edge"}, \NoSuper,  
        \left(\begin{aligned}
            (&\text{``label"}, \StringT), \\
            (&\text{``source"}, \ObjT(\text{``Node1"}, \_, \_)), \\
            (&\text{``destination"}, \ObjT(\text{``Node2"}, \_, \_)) \\             
        \end{aligned}\right)\right)\right)
\end{align*}
                

\section{Values}

Now that we have a description of valid graph structures for some
interpreter, we need to define a language for describing specific 
graphs. 

\begin{align*}
    \Value =& \StringV(\Type_1, \String_1) \quad\where \Type_1 <: \StringT \\
    &| \NumberV(\Type_1, \Number_1) \quad\where \Type_1 <: \NumberT \\
    &| \BooleanV(\Type_1, \Boolean_1) \quad\where \Type_1 <: \BooleanT \\
    &| \ObjV(\Type_1, V=((\String_1, \ValueRef_1), ...)) \quad\where 
    \ObjPairsMatch(\ObjFields(\Type_1), V) \\
    &| \UnionV(\UnionT(..., \Type_i, ...), \ValueRef_1) \where
    \ValueType(\ValueRef_1) <: \Type_i\\
    &| \ListV(\ListT(\Type_1), (\ValueRef_1, ...)) \where \ValueType(\ValueRef_i) <: \Type_1 \\
    &| \SetV(\SetT(\Type_1), \{\ValueRef_1, ...\}) \where \ValueType(\ValueRef_i) <: \Type_1 \\
    &| \MapV(\MapT(\Type_1, \Type_2), ((\ValueRef_{1,1}, \ValueRef_{2,1}), ...)) \where \bigwedge
    \begin{aligned}
        \ValueType(\ValueRef_{1, i}) <: \Type_1 \\
        \ValueType(\ValueRef_{2, i}) <: \Type_2 
    \end{aligned}\\
\end{align*}

\begin{align*}
    \ObjFields(\ObjT(\_, \String_S, (P_1 = (\String_1, \Type_1), ...))) &= \operatorname{concat}(\ObjFields(\LookupObjRef(\String_S), (P_n))) \\
    \ObjFields(\InterT(ObjT_1, ...)) &= \operatorname{concat}(\ObjFields(\ObjT_1), ...)
\end{align*}

\begin{align*}
    \ValueType(\ValueRef_1) &= \ValueType(\operatorname{deref}(\ValueRef_1))\\
    \ValueType(\StringV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\NumberV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\BooleanV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\ObjV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\UnionV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\ListV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\SetV(\Type_1, \_)) &= \Type_1 \\
    \ValueType(\MapV(\Type_1, \_)) &= \Type_1 \\
\end{align*}
\begin{align*}
    \ObjPairsMatch(((\String_1, \Type_1),...), ((\String_1, \ValueRef_1), ...)) 
    \textif \forall i, \ValueType(\ValueRef_i) <: \Type_i
\end{align*}

\begin{align*}
    \operatorname{getref} &: \Value \rightarrow \ValueRef \\
    \operatorname{deref}(\operatorname{getref}(\Value_1)) &= \Value_1 \\
\end{align*}

A valid graph then matches 
\[(\ListV(\ListT(\operatorname{Nodes}), \_), \ListV(\ListT(\operatorname{Edges}), \_))\]
for some appropriate definition of Nodes and Edges.
\end{document}